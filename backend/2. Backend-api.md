# Backend API.

we already have the auth working. Using Cognito. and JWT.

Now we need to create the API.
this is the constructor of my task model:
```js
export class Task {
  constructor(id, title) {
    this.id = id;
    this.title = title;
    this.intervals = []; // [{start: number, end?: number}]
    this.archived = false;
    this.tags = [];
  }

  get isRunning() {
    const last = this.intervals[this.intervals.length - 1];
    return !!last && last.end == null;
  }

  start(at = Date.now()) {
    if (this.isRunning) return;
    this.intervals.push({ start: at });
  }

  pause(at = Date.now()) {
    if (!this.isRunning) return;
    const last = this.intervals[this.intervals.length - 1];
    last.end = at;
  }

  reset() {
    this.intervals = [];
  }

  // total elapsed ms
  elapsed(at = Date.now()) {
    let total = 0;
    for (const itv of this.intervals) {
      const end = itv.end ?? at;
      total += Math.max(0, end - itv.start);
    }
    return total;
  }
}
```
then, it will be saved in the users browser.
I need to sync it with dynamodb.

# PLAN

Goal
- Keep tasks primarily in the client (localStorage/IndexedDB) and provide a background-safe sync with DynamoDB so users can back up, restore, and use the same data across devices.

Data model in DynamoDB
- Table: tasks
- Keys:
  - PK: USER#<phone>
  - SK: TASK#<taskId>
- Attributes per item:
  - id: string (taskId)
  - title: string
  - intervals: array of {start:number, end?:number}
  - archived: boolean
  - tags: array of strings
  - updatedAt: number (ms epoch) — used for conflict resolution
  - version: number (client increments on each local save)

Optional GSIs (defer unless needed)
- GSI1 (by archived): PK = USER#<phone>, SK = ARCH#<archived>#<updatedAt>
- GSI2 (by tag, denormalized): one item per tag is overkill for V1; skip for now.

Auth and identity
- Use existing Cognito JWT from the phone+code login (idToken/accessToken stored by the app).
- Proxy verifies the token (via AWS SDK/JWKS) and derives phone from claims to build PK.

API surface (behind auth-proxy)
- POST /sync/upload
  - Body: { tasks: Task[], lastSyncAt?: number }
  - Behavior: upsert tasks with optimistic concurrency (ConditionalExpression on version). If a conflict occurs, return conflicting items with their server copy.
- GET /sync/download?since=<ms>
  - Returns tasks updated since the given timestamp for this user. Paginate if needed.
- POST /tasks/delete
  - Body: { ids: string[] }
  - Soft-delete is not necessary because we carry archived flag; delete removes the item.

Conflict resolution
- Each task carries updatedAt and version.
- Client increments version and sets updatedAt on each local write.
- Upload uses conditional put: only write if serverVersion == (clientVersion-1) OR item not exists.
- On ConditionalCheckFailed, server returns { conflict: true, server: <item> } for that task; client resolves using "newer-wins" by updatedAt (default) or prompts user in a future version.

Batching and pagination
- Upload in batches of up to 25 tasks (DynamoDB Transact/BatchWrite limits). For V1, use BatchWrite (no transaction) with per-item conditional expressions via PutItem loops.
- Download uses Query on PK with FilterExpression updatedAt > :since; paginate via LastEvaluatedKey.

Latency and cost
- Keep payloads compact: intervals can grow; client should collapse contiguous running segments and optionally trim extremely old intervals in a future version.

Backend implementation outline
- auth-proxy will add endpoints:
  - POST /sync/upload
  - GET /sync/download
  - POST /tasks/delete
- Use AWS SDK v3 (DynamoDBDocumentClient) with a single table.
- Authorization: require Authorization: Bearer <idToken>; verify once per request (cache JWKS).

Client sync strategy (V1)
- On login: perform a full download (since=0) and merge into client store using newer-wins by updatedAt.
- On local changes: debounce 1–2 seconds, then upload changed tasks (those whose local updatedAt > lastUploadedAt per task).
- On app load: attempt a background download with since=lastSuccessfulSyncAt.
- Store lastSuccessfulSyncAt in localStorage.

Failure handling
- If upload returns conflicts, keep both copies in memory and prefer server if server.updatedAt > client.updatedAt; otherwise retry upload with incremented version.
- Network failures: queue pending uploads and retry with exponential backoff (2s, 5s, 10s).

IAM and security
- Proxy role: least-privileged access to the tasks table (partition by user, but IAM can’t filter rows; rely on app logic and token-derived PK).
- Rate limit at proxy with basic in-memory token bucket for abuse prevention.

Terraform (follow-up PR)
- Create DynamoDB table tasks with PK (pk) and SK (sk), on-demand capacity, TTL disabled for now.
- Wire auth-proxy with environment variables: TABLE_NAME, REGION.

Milestones back and front
1) Skeleton endpoints in auth-proxy with in-memory store (dev-only) and test from browser.
2) Add DynamoDB persistence and basic upload/download.
3) Add optimistic concurrency and conflict responses.
4) Add client sync debounce and lastSuccessfulSyncAt tracking.
6) Optional: incremental download (since) and pagination in UI tests.